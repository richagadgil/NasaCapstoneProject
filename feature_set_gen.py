# -*- coding: utf-8 -*-
"""Copy of feature_set_gen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11hXq8f92bjE6CdM2mL_xh_aEFs1op5vl
"""

import numpy as np
import pandas as pd

def gen_ideal(spectra, mode_loc, verbose = False):
  labeled_modes=[]
  for i in range(spectra.shape[2]):
    if verbose: print("spectra number: "+str(i))
    amp=[]
    length = np.shape(spectra)[0]
    modes = [x[i]*length for x in mode_loc]
    seeker = 0
    modes = np.sort(modes)
    for j in range(length):
      all_amp = [0]
      while seeker < len(modes) and modes[seeker] <= j+100:
          # print(np.exp(np.square((j-modes[seeker])/100)))
        all_amp.append(1/(np.exp(np.square((j-modes[seeker])/10))))
        seeker += 1
      while seeker < len(modes) and seeker >= 0 and modes[seeker] >= j-100:
        # print(modes[seeker])
        seeker -= 1
      seeker = max(seeker,0)
      amp.append(max(all_amp))
      if verbose and j %100000 ==0: print('.',end='')
    labeled_modes.append(amp)
    if verbose: print(len(amp))
  return labeled_modes

# training set generation
def get_train(spectra, width = 5, length = 1000):
  train_set = []
  for i in range(spectra.shape[2]):
    all_channels = pd.DataFrame(np.transpose(np.transpose(spectra)[i]))
    channel_num = spectra.shape[1]
    channel_sets = int(channel_num/width)*width
    x = []
    for s in np.reshape(range(channel_sets),(int(channel_sets/width),width)):
      x.append(np.reshape(np.array(all_channels[s]),(int(len(np.array(all_channels[s]))/length),length,width)))
    train_set.append(x)
  return train_set

def get_feature_set(spectra, modes, width = 5, length = 1000,verbose=False):
  print("generating ideal spectra...")
  ideal = gen_ideal(spectra,modes,verbose)
  print("generating training set...")
  train = get_train(spectra, width=width, length = length)
  print("reshaping data...")
  x = np.reshape(train, (np.prod(np.shape(train)[:3]),length,width))

  y = []
  for i in range(np.shape(train)[0]):
    for j in range(np.shape(train)[1]):
      y.extend(ideal[i])
  return x, y