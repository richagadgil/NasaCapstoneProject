# -*- coding: utf-8 -*-
"""Copy of performance_metrics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vm6XtZySA05niZRavz3c650RyA_TtfZV
"""

import numpy as np
from numpy.testing import assert_allclose
from keras.models import Sequential, load_model
from keras.layers import LSTM, Dropout, Dense
from keras.callbacks import ModelCheckpoint
!pip install plotly --upgrade  # make sure your plotly is up to date

import plotly.express as px
import numpy as np
import pandas as pd
from scipy.io import loadmat
import matplotlib.pyplot as plt

"""tp = num_pairs

fp = in pred modes but not in modes = len(predicted_modes) - num_pairs

tn = does not exist

fn = in modes but not in pred modes = len(modes) - num_pairs
"""

# Inputs: sorted np.arrays of modes, predicted modes, and optional threshold
# Outputs: number of correct predictions, list of correct actual modes, list of correct predicted modes
def get_correct_preds(modes, predicted_modes, threshold = 50):
  modes = np.array(modes)
  modes.sort()
  mode_dists = np.abs(predicted_modes[:, np.newaxis] - modes)
  dist_df = pd.DataFrame(mode_dists.flatten(), columns = ['distance'])
  dist_df['predicted_index'] = np.indices((mode_dists.shape[0], mode_dists.shape[1]))[0].flatten()
  dist_df['actual_index'] = np.indices((mode_dists.shape[0], mode_dists.shape[1]))[1].flatten()

  filter_df = dist_df[dist_df['distance']<50]
  sort_df = filter_df.sort_values(filter_df.columns[0])
  dist_arr = sort_df.to_numpy()

  p_actual= []
  p_pred = []
  num_pairs = 0
  for item in dist_arr:
    if item[1] not in p_pred and item[2] not in p_actual:
      p_pred.append(item[1])
      p_actual.append(item[2])
      num_pairs += 1

  return num_pairs, p_actual, p_pred

# Inputs: number of correct predictions, actual modes, predicted modes
def get_precision_recall_f1(num_pairs, modes, predicted_modes):
  fp = len(predicted_modes) - num_pairs
  fn = len(modes) - num_pairs
  precision = num_pairs / (num_pairs + fp)
  recall = num_pairs / (num_pairs + fn)
  f1 = 2 * precision * recall / (precision + recall)
  return precision, recall, f1

# final_neighbors = get_correct_preds(modes, predicted_modes, 50)
# tp = final_neighbors[0]
# tp

# get_precision_recall_f1(tp, modes, predicted_modes)

